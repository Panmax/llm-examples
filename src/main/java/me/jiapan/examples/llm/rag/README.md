## RAG 阶段

### 索引 Indexing

在索引阶段，文档会被预处理，以便在检索阶段实现高效搜索。

这个过程可能因所使用的信息检索方法而异。对于向量搜索，这通常包括清理文档，用额外的数据和元数据丰富它们，将它们分割成更小的片段（即分块），向量化这些片段，并最终将它们存储在Embedding存储中（即向量数据库）。

索引阶段通常在**离线进行**，这意味着不需要终端用户等待其完成。这可以通过例如每周末重新索引公司内部文档的定时任务来实现。负责索引的代码也可以是一个只处理索引任务的独立应用程序。

索引阶段的简化图:
<img src="https://docs.langchain4j.dev/assets/images/rag-ingestion-9b548e907df1c3c8948643795a981b95.png" style="zoom: 50%;" />

### 检索 Retrieval

检索阶段通常在线进行，当用户提交一个问题时，应该使用已索引的文档来回答。

这个过程可能会根据所使用的信息检索方法而有所不同。对于向量搜索，这通常涉及将用户的查询（问题）向量化并在 embedding 存储中执行相似性搜索。相关段落（原始文档的一部分）被注入提示并发送到LLM。

检索阶段的简化图:
<img src="https://docs.langchain4j.dev/assets/images/rag-retrieval-f525d2937abc08fed5cec36a7f08a4c3.png" style="zoom:33%;" />

## 整个 RAG 检索流程分解为更细粒度的步骤和基本组件

<img src="https://docs.langchain4j.dev/assets/images/advanced-rag-fb84283d02470b835ff2f4913f08fdbf.png"  />

### QueryTransformer: 

将给定的查询转换为一个或多个查询。

目标是通过修改或扩展原始查询来提高检索质量。

一些已知的改进检索的方法包括：
- 查询压缩：将给定的查询和聊天记忆（先前的对话历史）压缩成简洁的查询。
- 查询扩展：
- 查询重写：通过提示LLM或者使用专门的“问题重写器”（通常是经过微调的小型Transformer）来对用户的问题进行改写。
- 回退提示：提示LLM提出一个关于高层次概念或原则的抽象通用问题（称之为“后退”问题）。后退问题的抽象程度需要根据特定任务进行调整。最终后退问题和原始问题一起进行检索。例如，对于问题“Estella Leopold在1954年8月至11月期间上了哪所学校？”这个问题很难直接解决，因为有时间范围的详细限制。在这两种情况下，提出一个后退问题“Estella Leopold的教育经历怎么样的？”则有助于系统的检索。
- 假设文档嵌入 (HyDE)：用LLM生成一个“假设”答案，将其和问题一起进行检索。HyDE的核心思想是接收用户提问后，先让LLM在没有外部知识的情况下生成一个假设性的回复。然后，将这个假设性回复和原始查询一起用于向量检索。假设回复可能包含虚假信息，但蕴含着LLM认为相关的信息和文档模式，有助于在知识库中寻找类似的文档。

### QueryRouter

将给定的查询路由到一个或多个内容检索器。

目标是确保仅从相关数据源中检索内容。

一些潜在的方法包括：
- 利用大型语言模型（LLM）
- 使用文本分类器（又称“语义路由”）

### ContentRetriever

使用给定的查询从底层数据源检索内容。

目标是仅检索与给定查询相关的内容。

底层数据源可以是任何内容：
- Embedding（向量）存储
- 全文搜索引擎
- 网络搜索引擎
- 知识图谱
- SQL数据库

### ContentAggregator

汇总所有使用所有 Query 从所有 ContentRetriever 检索到的 Content。

目标是确保仅向 LLM 呈现最相关且不重复的 {@link Content}。

一些有效的方法包括：
- 重排序
- 互惠排名融合

### ContentInjector